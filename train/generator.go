package main

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"time"
)

// We will need to make synthetic data for training the model
//
// Due to the current state of gnoland in constant state of development,
// the program will need to make synthetic data for training of the dictionary.
//
// This file will contain the code to generate the synthetic data.
// While not are 100% accurate, they will be close enough to the real data to be useful for training.
//
// Some of the packages are generated by AI, because the network reset again
// until I can get a better look at some of the packages this will just be like a placeholder.
// TODO: add real packages and look at real data when it becomes available. For now focus on native postgres format.

// TODO remove these types and replace them with one generated by protobuf
type Event struct {
	AtType  string      `json:"@type"`
	Type    string      `json:"type"`
	Attrs   []Attribute `json:"attrs"`
	PkgPath string      `json:"pkg_path"`
}

type Attribute struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type TxEvents struct {
	Events []Event `json:"Events"`
}

// Data generators
type DataGenerator struct {
	rand *rand.Rand
}

func NewDataGenerator() *DataGenerator {
	return &DataGenerator{
		rand: rand.New(rand.NewSource(time.Now().UnixNano())),
	}
}

// Generate Gno address: g1 + 38 characters (bech32 format)
func (g *DataGenerator) GenerateAddress() string {
	chars := "abcdefghijklmnopqrstuvwxyz0123456789"
	result := "g1"
	for i := 0; i < 38; i++ {
		result += string(chars[g.rand.Intn(len(chars))])
	}
	return result
}

// Generate amount with ugnot suffix
func (g *DataGenerator) GenerateAmount() string {
	amount := g.rand.Intn(10000000000) + 1000 // from 0.001 to 10K GNOT because 1 GNOT = 1000000 ugnot
	return fmt.Sprintf("%d ugnot", amount)
}

// Generate bytes value
func (g *DataGenerator) GenerateBytesValue() string {
	bytes := g.rand.Intn(50000) + 100 // 100 to 50K bytes
	return fmt.Sprintf("%d bytes", bytes)
}

// Generate transaction hash
func (g *DataGenerator) GenerateTxHash() string {
	chars := "ABCDEF0123456789"
	result := ""
	for i := 0; i < 64; i++ { // SHA256 hex length
		result += string(chars[g.rand.Intn(len(chars))])
	}
	return result
}

// Generate package path variants
func (g *DataGenerator) GeneratePackagePath() string {
	packages := []string{
		"gno.land/r/demo/profile",
		"gno.land/r/demo/board",
		"gno.land/r/demo/users",
		"gno.land/r/gnoland/blog",
		"gno.land/r/gnoland/home",
		"gno.land/p/demo/avl",
		"gno.land/p/demo/ufmt",
	}
	return packages[g.rand.Intn(len(packages))]
}

// Event type templates
var eventTemplates = map[string]func(*DataGenerator) Event{
	"ProfileFieldCreated": func(g *DataGenerator) Event {
		fieldTypes := []string{"StringField", "IntField", "BoolField", "AddressField"}
		displayNames := []string{"alice", "bob", "charlie", "noderunner", "validator", "testuser"}

		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "ProfileFieldCreated",
			Attrs: []Attribute{
				{Key: "FieldType", Value: fieldTypes[g.rand.Intn(len(fieldTypes))]},
				{Key: "DisplayName", Value: displayNames[g.rand.Intn(len(displayNames))] + fmt.Sprintf("%d", g.rand.Intn(1000))},
			},
			PkgPath: "gno.land/r/demo/profile",
		}
	},

	"StorageDeposit": func(g *DataGenerator) Event {
		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "StorageDeposit",
			Attrs: []Attribute{
				{Key: "Deposit", Value: g.GenerateAmount()},
				{Key: "Storage", Value: g.GenerateBytesValue()},
			},
			PkgPath: g.GeneratePackagePath(),
		}
	},

	"Transfer": func(g *DataGenerator) Event {
		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "Transfer",
			Attrs: []Attribute{
				{Key: "from", Value: g.GenerateAddress()},
				{Key: "to", Value: g.GenerateAddress()},
				{Key: "amount", Value: g.GenerateAmount()},
			},
			PkgPath: "gno.land/r/demo/users",
		}
	},

	"BoardCreated": func(g *DataGenerator) Event {
		boardNames := []string{"general", "development", "trading", "governance", "support"}
		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "BoardCreated",
			Attrs: []Attribute{
				{Key: "BoardID", Value: fmt.Sprintf("%d", g.rand.Intn(10000))},
				{Key: "Name", Value: boardNames[g.rand.Intn(len(boardNames))]},
				{Key: "Creator", Value: g.GenerateAddress()},
			},
			PkgPath: "gno.land/r/demo/board",
		}
	},

	"PostCreated": func(g *DataGenerator) Event {
		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "PostCreated",
			Attrs: []Attribute{
				{Key: "PostID", Value: fmt.Sprintf("%d", g.rand.Intn(100000))},
				{Key: "BoardID", Value: fmt.Sprintf("%d", g.rand.Intn(10000))},
				{Key: "Author", Value: g.GenerateAddress()},
				{Key: "Title", Value: fmt.Sprintf("Post Title %d", g.rand.Intn(1000))},
			},
			PkgPath: "gno.land/r/demo/board",
		}
	},
}

// Generate synthetic transaction events
func (g *DataGenerator) GenerateTransaction() TxEvents {
	// Random number of events (1-5 per transaction, weighted toward 1-2)
	numEvents := 1
	if g.rand.Float32() < 0.3 {
		numEvents = 2
	}
	if g.rand.Float32() < 0.1 {
		numEvents = g.rand.Intn(3) + 3 // 3-5 events (rare)
	}

	events := make([]Event, numEvents)
	eventTypes := []string{"ProfileFieldCreated", "StorageDeposit", "Transfer", "BoardCreated", "PostCreated"}

	for i := 0; i < numEvents; i++ {
		eventType := eventTypes[g.rand.Intn(len(eventTypes))]
		events[i] = eventTemplates[eventType](g)
	}

	return TxEvents{Events: events}
}

// Generate dataset for training
func GenerateTrainingDataset(numTransactions int) [][]byte {
	generator := NewDataGenerator()
	dataset := make([][]byte, numTransactions)

	for i := 0; i < numTransactions; i++ {
		tx := generator.GenerateTransaction()
		jsonData, _ := json.Marshal(tx)
		dataset[i] = jsonData
	}

	return dataset
}

// Example usage
func main() {
	// Generate 10K synthetic transactions for training
	fmt.Println("Generating synthetic training data...")

	dataset := GenerateTrainingDataset(10000)

	// from here we will need to convert the dataset to protobuf
	// remove the current types and replace them with one generated by protobuf
	// then we will need to convert all of the events to protobuf
	// and then we train zstandard dictionary
}
