package generator

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"time"

	"github.com/Cogwheel-Validator/spectra-gnoland-indexer/pkgs/sql_data_types"
)

// We will need to make synthetic data for training the model
//
// Due to the current state of gnoland in constant state of development,
// the program will need to make synthetic data for training of the dictionary.
//
// This file will contain the code to generate the synthetic data.
// While not are 100% accurate, they will be close enough to the real data to be useful for training.
//
// Some of the packages are generated by AI, because the network reset again
// until I can get a better look at some of the packages this will just be like a placeholder.
// TODO: add real packages and look at real data when it becomes available. For now focus on native postgres format.

// TODO remove these types and replace them with one generated by protobuf
type Event struct {
	AtType  string      `json:"@type"`
	Type    string      `json:"type"`
	Attrs   []Attribute `json:"attrs"`
	PkgPath string      `json:"pkg_path"`
}

type Attribute struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type TxEvents struct {
	Events []Event `json:"Events"`
}

// Data generators
type DataGenerator struct {
	rand        *rand.Rand
	cryptoGen   *CryptoGenerator
	keyPairPool []*KeyPair
}

func NewDataGenerator() *DataGenerator {
	seed := time.Now().UnixNano()
	cryptoGen := NewCryptoGenerator(seed)

	return &DataGenerator{
		rand:        rand.New(rand.NewSource(seed)),
		cryptoGen:   cryptoGen,
		keyPairPool: cryptoGen.GenerateKeyPairPool(50), // Pre-generate 50 key pairs for efficiency
	}
}

// GenerateAddress generates an authentic Gno bech32 address from real cryptographic keys
func (g *DataGenerator) GenerateAddress() string {
	return g.cryptoGen.AddressFromPool(g.keyPairPool)
}

// GenerateAuthenticAddress generates a completely new authentic address (slower)
func (g *DataGenerator) GenerateAuthenticAddress() string {
	return g.cryptoGen.GenerateAuthenticAddress()
}

// GenerateAuthenticPubKey generates a completely new authentic public key (slower)
func (g *DataGenerator) GenerateAuthenticPubKey() string {
	return g.cryptoGen.GenerateAuthenticPubKey()
}

// GeneratePubKey generates an authentic Gno bech32 public key from the pool
func (g *DataGenerator) GeneratePubKey() string {
	return g.cryptoGen.PubKeyFromPool(g.keyPairPool)
}

// GetRandomKeyPair returns a random key pair from the pool for advanced usage
func (g *DataGenerator) GetRandomKeyPair() *KeyPair {
	if len(g.keyPairPool) == 0 {
		return g.cryptoGen.GenerateKeyPair()
	}
	return g.keyPairPool[g.rand.Intn(len(g.keyPairPool))]
}

// Generate amount with ugnot suffix
func (g *DataGenerator) GenerateAmount() sql_data_types.Amount {
	amount := uint64(g.rand.Intn(10000000000) + 1000) // from 0.001 to 10K GNOT because 1 GNOT = 1000000 ugnot
	return sql_data_types.Amount{
		Amount: amount,
		Denom:  "ugnot",
	}
}

// Generate amount string
func (g *DataGenerator) GenerateAmountString() string {
	return fmt.Sprintf("%d ugnot", g.GenerateAmount().Amount)
}

// Generate bytes value
func (g *DataGenerator) GenerateBytesValue() string {
	bytes := g.rand.Intn(50000) + 100 // 100 to 50K bytes
	return fmt.Sprintf("%d bytes", bytes)
}

// Generate blocks hash
func (g *DataGenerator) GenerateBlockHash() string {
	chars := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
	result := ""
	length := g.rand.Intn(44)

	for i := 0; i < length; i++ {
		result += string(chars[g.rand.Intn(len(chars))])
	}
	return result
}

// Generate package path variants
func (g *DataGenerator) GeneratePackagePath() string {
	packages := []string{
		"gno.land/r/demo/profile",
		"gno.land/r/demo/board",
		"gno.land/r/demo/users",
		"gno.land/r/gnoland/blog",
		"gno.land/r/gnoland/home",
		"gno.land/p/demo/avl",
		"gno.land/p/demo/ufmt",
		"gno.land/r/dex/trade",
	}
	return packages[g.rand.Intn(len(packages))]
}

// Event type templates
var eventTemplates = map[string]func(*DataGenerator) Event{
	"ProfileFieldCreated": func(g *DataGenerator) Event {
		fieldTypes := []string{"StringField", "IntField", "BoolField", "AddressField"}
		displayNames := []string{"alice", "bob", "charlie", "noderunner", "validator", "testuser"}

		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "ProfileFieldCreated",
			Attrs: []Attribute{
				{Key: "FieldType", Value: fieldTypes[g.rand.Intn(len(fieldTypes))]},
				{Key: "DisplayName", Value: displayNames[g.rand.Intn(len(displayNames))] + fmt.Sprintf("%d", g.rand.Intn(1000))},
			},
			PkgPath: "gno.land/r/demo/profile",
		}
	},

	"StorageDeposit": func(g *DataGenerator) Event {
		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "StorageDeposit",
			Attrs: []Attribute{
				{Key: "Deposit", Value: g.GenerateAmountString()},
				{Key: "Storage", Value: g.GenerateBytesValue()},
			},
			PkgPath: g.GeneratePackagePath(),
		}
	},

	"Transfer": func(g *DataGenerator) Event {
		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "Transfer",
			Attrs: []Attribute{
				{Key: "from", Value: g.GenerateAddress()},
				{Key: "to", Value: g.GenerateAddress()},
				{Key: "amount", Value: g.GenerateAmountString()},
			},
			PkgPath: "gno.land/r/demo/users",
		}
	},

	"BoardCreated": func(g *DataGenerator) Event {
		boardNames := []string{"general", "development", "trading", "governance", "support"}
		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "BoardCreated",
			Attrs: []Attribute{
				{Key: "BoardID", Value: fmt.Sprintf("%d", g.rand.Intn(10000))},
				{Key: "Name", Value: boardNames[g.rand.Intn(len(boardNames))]},
				{Key: "Creator", Value: g.GenerateAddress()},
			},
			PkgPath: "gno.land/r/demo/board",
		}
	},

	"PostCreated": func(g *DataGenerator) Event {
		return Event{
			AtType: "/tm.GnoEvent",
			Type:   "PostCreated",
			Attrs: []Attribute{
				{Key: "PostID", Value: fmt.Sprintf("%d", g.rand.Intn(100000))},
				{Key: "BoardID", Value: fmt.Sprintf("%d", g.rand.Intn(10000))},
				{Key: "Author", Value: g.GenerateAddress()},
				{Key: "Title", Value: fmt.Sprintf("Post Title %d", g.rand.Intn(1000))},
			},
			PkgPath: "gno.land/r/demo/board",
		}
	},
}

// Generate synthetic transaction events
func (g *DataGenerator) GenerateTransaction() TxEvents {
	// Random number of events (1-5 per transaction, weighted toward 1-2)
	numEvents := 1
	if g.rand.Float32() < 0.3 {
		numEvents = 2
	}
	if g.rand.Float32() < 0.1 {
		numEvents = g.rand.Intn(3) + 3 // 3-5 events (rare)
	}

	events := make([]Event, numEvents)
	eventTypes := []string{"ProfileFieldCreated", "StorageDeposit", "Transfer", "BoardCreated", "PostCreated"}

	for i := 0; i < numEvents; i++ {
		eventType := eventTypes[g.rand.Intn(len(eventTypes))]
		events[i] = eventTemplates[eventType](g)
	}

	return TxEvents{Events: events}
}

// Generate dataset for training
func GenerateTrainingDataset(numTransactions int) [][]byte {
	generator := NewDataGenerator()
	dataset := make([][]byte, numTransactions)

	for i := 0; i < numTransactions; i++ {
		tx := generator.GenerateTransaction()
		jsonData, _ := json.Marshal(tx)
		dataset[i] = jsonData
	}

	return dataset
}
